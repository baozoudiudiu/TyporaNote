## 远程推送通知小记

现在已经不适配iOS10之前版本，所以就不讨论了。这里只讨论iOS10之后的。

* 注册通知

  ```swift
  if #available(iOS 10.0, *) {
              UNUserNotificationCenter.current().delegate = self
              UNUserNotificationCenter.current().getNotificationSettings { (settings) in
                  switch settings.authorizationStatus {
                  case .authorized:
                      DispatchQueue.main.async {
                          UIApplication.shared.registerForRemoteNotifications()
                          print(UIApplication.shared.isRegisteredForRemoteNotifications)
                      }
                  case .notDetermined:
                      UNUserNotificationCenter.current().requestAuthorization(options: [.badge, .alert, .sound]) { (granted, error) in
                          if granted {
                              DispatchQueue.main.async {
                                  UIApplication.shared.registerForRemoteNotifications()
                                  print(UIApplication.shared.isRegisteredForRemoteNotifications)
                              }
                          }
                      }
                  default:
                      break
                  }
              }
          } else {
              // Fallback on earlier versions
          }
  ```

  

* 获取token，iOS13前后有区别

  ```swift
  func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    if #available(iOS 13.0, *) {
        var deviceTokenString: String = ""
        let bytes = [UInt8](deviceToken)
        for item in bytes {
            deviceTokenString += String(format:"%02x", item&0x000000FF)
        }
        print("注册deviceToken:\(deviceTokenString)")
    }else {
        let deviceTokenString = deviceToken.map { String(format: "%02.2hhx", arguments: [$0]) }.joined()
        print("注册deviceToken:\(deviceTokenString)")
    }
  }
  ```

  

* app在前台时收到推送时的回调，将它取名为A

  ```swift
  @available(iOS 10.0, *)
      func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
          completionHandler([.sound, .badge])
      }
  ```

* app在后台收到推送后，点击通知栏时的回调，将他取名为B

  ```swift
  @available(iOS 10.0, *)
      func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
          completionHandler()
      }
  ```

* 收到静默推送（**content-available**）时的回调，将他取名为C

  ```swift
  // 专门用来处理"content-available"推送
  func application(_ application: UIApplication,didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
    if UIApplication.shared.applicationState == .background {
  
    }else if UIApplication.shared.applicationState == .active {
  
    }
    completionHandler(.newData)
  }
  ```

确定了上面三个回调之后，开始捋一捋推送处理流程



